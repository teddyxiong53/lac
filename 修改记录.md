# cjson

这个不用写，但是以编译这个为入口，把autotools的编译链接过程走通。

现在可以编译通过。但是生成的只有la结尾的文件。没有看到a或者so文件。

# tinyparam

C语言切分字符串

https://blog.csdn.net/SweeNeil/article/details/84787945

```
char *strtok_r(char *str, const char *delim, char **saveptr);
```

这个才是线程安全的。

测试代码：

```
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "system.audio.volume";
    char* ptr;
    char* p;
    printf("before strtok:  str=%s\n", str);
    printf("begin:\n");
    ptr = strtok_r(str, ".", &p);
    while (ptr != NULL) {
        printf("str=%s\n", str);
        printf("ptr=%s\n", ptr);
        ptr = strtok_r(NULL, ".", &p);
    }
    return 0;
}
```

这样打印出来是：

```
before strtok:  str=system.audio.volume
begin:
str=system
ptr=system
str=system
ptr=audio
str=system
ptr=volume
```

那我以ptr的作为取值对象。

代码这样：

```
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "system.audio.volume";
    char* ptr;
    char* p;
    printf("before strtok:  str=%s\n", str);
    ptr = strtok_r(str, ".", &p);
    while (ptr != NULL) {
        printf("ptr=%s\n", ptr);
        ptr = strtok_r(NULL, ".", &p);
    }
    return 0;
}
```

写入的时候，进行truncate操作。前面会有一堆的NUL。

需要rewind一下。

现在tinyparam功能完成了。

# tinyev

接下来是实现tinyev。

这个就比较麻烦一点。需要先研究一下libev的内容。

我就用3个文件：ev.c、ev.h、ev_epoll.c。

看了一下代码风格，真的是非常别扭。但是回头看了一下libtuv。这个文件就是比较多。

相比之下，还是libev代码量算是少的。

我先保证可以把这个例子编译运行起来。

```
#include <ev.h>
#include <stdio.h>
#include <signal.h>
#include <sys/unistd.h>

ev_io io_w;
ev_timer timer_w;
ev_signal signal_w;

void io_action(struct ev_loop *main_loop, ev_io *io_w, int e)
{
    int ret;
    char buf[1024] = {0};
    puts("in io cb\n");
    read(STDIN_FILENO, buf, sizeof(buf));
    buf[1023] = '\0';
    printf("read a string:%s\n", buf);
    ev_io_stop(main_loop, io_w);
}
void timer_action(struct ev_loop *main_loop, ev_timer *timer_w, int e)
{
    puts("in timer cb\n");
    ev_timer_stop(main_loop, timer_w);
}
void signal_action(struct ev_loop *main_loop, ev_signal *signal_w, int e)
{
    puts("in signal cb\n");
    ev_signal_stop(main_loop, signal_w);
    ev_break(main_loop, EVBREAK_ALL);
}

int main(int argc, char const *argv[])
{
    struct ev_loop *main_loop = ev_default_loop(0);
    ev_init(&io_w, io_action);
    ev_io_set(&io_w, STDIN_FILENO, EV_READ);
    ev_init(&timer_w, timer_action);
    ev_timer_set(&timer_w, 2,0);
    ev_init(&signal_w, signal_action);
    ev_signal_set(&signal_w, SIGINT);

    ev_io_start(main_loop, &io_w);
    ev_timer_start(main_loop, &timer_w);
    ev_signal_start(main_loop, &signal_w);
    ev_run(main_loop, 0);
    return 0;
}
```

ev_default_loop实现

EV_USE_REALTIME 这个功能我不用。

我只用EV_USE_MONOTONIC

写了几个函数后，感觉思路清晰一些了。

```
#define NUMPRI (EV_MAXPRI - EV_MINPRI + 1)
```

这个优先级我不用。所以NUMPRI为1.

```
实现ev_init
	这个必须实现为宏。
	因为传递进来的类型是多种。只能用宏来模拟c++的模板。
	
```

# jsonrpc

想明白了jsonrpc的通知怎么做了，

进程A作为server，内部同时运行jsonrpc server1和连接自己的client代码，

进程B作为纯的client。

当进程A有状态需要通知时，A内部的client向自己的server发通知，这个信息就会被server转给所有的client.

这样就实现了进程A主动给进程B发送通知的机制。

有了这个，jsonrpc就可以替代dbus的功能来实现进程通信了。

代码规划：

```
jsonrpc_server.c
	里面的对外接口：jrpc_server作为前缀
jsonrpc_client.c
	里面的对外接口，jrpc_client作为前缀。
	
无论server还是client，都以libev作为通信基础。
json库使用cjson。

至于消息的内容，需要后续编写过程中进行优化整理。

```

server端参考jsonrpc-c。

client端我刚无意中发现opensips里有一个实现，代码也很简练。可以参考一下。

我不太在意rpc的传递计算功能。

我只希望传递一个json命令过去。

所以在命令的制定上，我要再看一下snapcast里的做法。

从example切入。

先实现jrpc_server_init函数和jrpc_server结构体。

一个jrpc_server，应该有哪些属性呢？

```
作为server，应该有：
	port。
	一个evloop指针。
	一个ev_io来监听listen_watcher，监听连接。
	一个注册表，注册自己可以处理的所有命令。
		注册的命令用一个jrpc_procedure来表示。
		jrpc_procedure就一个name，一个函数，一个void *data。
		这个回调函数，需要一个jrpc_context。这个context包含了void *data，另外包含了错误信息。
		
```

作为一个server，还有有一个结构体来表示connection。

```
jrpc_connection
	一个connection，是一个io，所以有一个ev_io。
	对应了一个fd。
	有一个buffer来存放收到的消息。buffer配套了2个参数：pos和size。
```

主要的结构体都有了。

现在可以开始看jrpc_server_init做了什么。

server里只有一个ev_loop，用的是默认的。

那么如果要创建多个server实例，会怎么样呢？

应该也没事。

而且还提供了一个jrpc_server_init_with_ev_loop版本让你自己另外传递loop进去。

jrpc_server_init只是一个常用的简单版本而已。

因为每个server都有个ev_loop指针。

发现我用的cjson没有cJSON_Parse_Stream这个函数。

直接把这个函数的实现拷贝过来。不改版本。

jsonrpc_server实现了。整个流程还是非常清晰直观的。都是同步的行为。



今天出现很奇怪的现象，昨天我在另外一台电脑上完全正常的测试程序。

现在换了一台电脑编译运行，就不对了。

问题是ev_default_loop得到的是空指针。

为什么会这样？

if (ev_backend (EV_A)) 这个条件不满足了。

我知道了。因为我gitignore把config.h给忽略了。

而我目前是让libev里直接放了config.h。所以当前就缺失这个文件了。

加上config.h重新编译就好了。

现在测试接收json字符串。结果不对。

怎么收到的数据解析处理不对呢？

```
root->type:3
```

会不会是cjson解析这一步的不对呢？

我直接替换cjson的文件看看。

的确是的。

cjson代码里没有没有版本号呢？

这样很不便于版本管理啊。

现在是提示参数错误。

```
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
{
        "error":        {
                "code": -32600,
                "message":      "request is invalid"
        }
}
```

按道理不应该。

参数是可以不带的吧。

应该是我处理上有不对的地方。

是我判断的条件不对。改了就好了。

现在有个问题，就是只要有一次发送错了json。那么后面解析都不对了。

测试一下jsonrpc-c的。发现这个在解析出错后，client就退出了。

我是没有退出的。

我把jsonrpc-c也改成不退出的看看。

碰到一次错误解析后，之后还是正常的。

那就是我的代码还有问题。

从connection_cb开始看。

目前测试简单的几个字符发送。不会触发解析。我觉得这个符合预期。

但是随便发了几个字符，再发一个正常的json。

后面就一直错误无法恢复了。

当前对buffer这一块的处理，不是很直观。

需要把jsonrpc-c的调试一下。

也是一样的问题。

这个时候的buffer内容是这样。

```
fdfdf
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
```

需要在出错的时候，把buffer整个复位一下。

现在把server的destroy的逻辑写一下。

写好了。

现在开始写client端。

看看怎么用libev写tcp client。

这个例子可以参考。

https://github.com/coolaj86/libev-examples/blob/master/src/unix-echo-client.c



关键是搞清楚什么时候需要外往发送。

简单点，可以用一个event_handler来做一个event来触发。

但是我当前是首选的libev的方式。

我看的这个例子。是以stdin读取一行数据为触发条件。

逻辑是这样：

```
stdin收到一行数据。
把sockfd对应的watcher先进行ev_io_stop
然后设置
ev_io_set(&wather, sockfd, EV_READ|EV_WRITE)
然后
ev_io_start(loop, &watcher)

这样就会马上触发可写事件。
然后在send_cb里，真正send之后，马上要去掉对EV_WRITE的关注。
（必须要去掉，不然这个事件会一直触发的）。
ev_io_stop(loop, &watcher);
ev_io_set(&watcher, sockfd, EV_READ);
ev_io_start(loop, &watcher);

这个逻辑还是清晰的。
```

搞清楚这个。就可以开始设计我的逻辑。

```
我需要在什么时候，开始关注sockfd的EV_WRITE事件？
在jrpc_client_send_cmd里，把内容解析成字符串，填入到send_buf里之后，就可以用关注EV_WRITE的方式来触发调用到send_cb函数。

send_cb的可读事件，就是在收到server发来的数据之后。
可以在这里处理执行的命令的返回值。
需要根据返回值来决定是不是要重新发送命令。

接收消息还可能来自于server的主动通知。

可能出现这种情况：
server的主动通知跟自己发送命令的返回值同时被收到。这样就可能导致解析出问题吧。
但是这个现在不管。后面在仔细考虑这个场景。
我觉得关键是要server端进行序列化操作。
排队处理。

```

现在总的逻辑理清楚了。可以开始写这部分逻辑了。

现在connect失败。

```
connect fail: Operation now in progress
```

这个是要把设置非阻塞放在connect之后。

现在的问题是，trigger之后，没有触发EV_WRITE。

那这个是不是跟epoll的设置有关系？

我直接拿这个例子来测试看看。

https://github.com/coolaj86/libev-examples/blob/master/src/unix-echo-client.c

这个需要server和client配套一起跑。

这个运行是正常的。说明libev和epoll没有问题。

那关键应该还是ev_io的设置问题。

需要梳理一下例子的逻辑：

```
remote_w
send_w
	这2个分别代表了什么？关系是什么？
	remote_w实际上用来表示connect的状态。
	connect成功后，就没有作用了。
	remote_W一上来就是关注它的EV_WRITE。如果可以write了。说明连接已经成功。
	
	send_w。就是socket的发送和接收用途。
	默认只关注EV_READ。
```

我暂时换一种方式来做这个发送的触发条件。

如果用pthread_cond。那还不如用eventfd来做触发。

刚好还可以跟libev结合起来。

但是eventfd是ev_async这个。所以我发现我对libev的用法还是没有完全掌握。

所以先不用这个机制。

我先解决我当前的问题。

notification怎么发送呢？

我自己加server的这个行为，就借用jsonrpc的消息格式和tcp的连接。

其实发的内容跟jsonrpc已经没有关系了。



测试用例用这么几条。

```
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
{"method": "add", "params": [1,2], "id":1}
```

我现在的server应该不管有没有id，都进行了回复的吧。

看看jsonrpc的规格书标准是怎么说的。

通知不允许被回复。

好像当前没有处理批量调用的情况吧。

测试一下看看能不能处理。

不能，因为只处理了object的类型。

其实要处理也可以。但是我先不支持吧。必要性不大。上层自己做一个for循环发送一下不就可以了吗？

测试一下多个client连接的情况。

我目前写的是限制了3个client。为什么连了4个也连上了呢？

我的代码写得有问题。改好了。

# mqtt

纯C语言实现一个mqtt client。

基于libev来做。

用libemqtt。

我看我之前用的是paho mqtt的。



# tinythpool

一个基于pthread的线程池。

这里有一个。就基于这个来改吧。

https://github.com/Pithikos/C-Thread-Pool

# file和string、time的util

怎么怎么放呢？如何命名呢？

要简单，但是也要有识别度，不要跟其他的库的命名冲突了。

就叫：

```
file_util_xx
str_util_xx
time_util_xx
misc_util_xx
```

啰嗦了点，但是可以保证唯一性。

写起来也比较顺手。

至于提取哪些函数放进来。还没有想好，先占个坑位吧。

# app

最后可以写一个app。是一个大的顶层结构体，把所有的其他库，都统一管理起来。

可以从avs sdk里找一些代码，写对应的C语言版本。



# http工具库

基于libcurl进行封装。

