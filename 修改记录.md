# cjson

这个不用写，但是以编译这个为入口，把autotools的编译链接过程走通。

现在可以编译通过。但是生成的只有la结尾的文件。没有看到a或者so文件。

# tinyparam

C语言切分字符串

https://blog.csdn.net/SweeNeil/article/details/84787945

```
char *strtok_r(char *str, const char *delim, char **saveptr);
```

这个才是线程安全的。

测试代码：

```
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "system.audio.volume";
    char* ptr;
    char* p;
    printf("before strtok:  str=%s\n", str);
    printf("begin:\n");
    ptr = strtok_r(str, ".", &p);
    while (ptr != NULL) {
        printf("str=%s\n", str);
        printf("ptr=%s\n", ptr);
        ptr = strtok_r(NULL, ".", &p);
    }
    return 0;
}
```

这样打印出来是：

```
before strtok:  str=system.audio.volume
begin:
str=system
ptr=system
str=system
ptr=audio
str=system
ptr=volume
```

那我以ptr的作为取值对象。

代码这样：

```
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "system.audio.volume";
    char* ptr;
    char* p;
    printf("before strtok:  str=%s\n", str);
    ptr = strtok_r(str, ".", &p);
    while (ptr != NULL) {
        printf("ptr=%s\n", ptr);
        ptr = strtok_r(NULL, ".", &p);
    }
    return 0;
}
```

写入的时候，进行truncate操作。前面会有一堆的NUL。

需要rewind一下。

现在tinyparam功能完成了。

# tinyev

接下来是实现tinyev。

这个就比较麻烦一点。需要先研究一下libev的内容。

我就用3个文件：ev.c、ev.h、ev_epoll.c。

看了一下代码风格，真的是非常别扭。但是回头看了一下libtuv。这个文件就是比较多。

相比之下，还是libev代码量算是少的。

我先保证可以把这个例子编译运行起来。

```
#include <ev.h>
#include <stdio.h>
#include <signal.h>
#include <sys/unistd.h>

ev_io io_w;
ev_timer timer_w;
ev_signal signal_w;

void io_action(struct ev_loop *main_loop, ev_io *io_w, int e)
{
    int ret;
    char buf[1024] = {0};
    puts("in io cb\n");
    read(STDIN_FILENO, buf, sizeof(buf));
    buf[1023] = '\0';
    printf("read a string:%s\n", buf);
    ev_io_stop(main_loop, io_w);
}
void timer_action(struct ev_loop *main_loop, ev_timer *timer_w, int e)
{
    puts("in timer cb\n");
    ev_timer_stop(main_loop, timer_w);
}
void signal_action(struct ev_loop *main_loop, ev_signal *signal_w, int e)
{
    puts("in signal cb\n");
    ev_signal_stop(main_loop, signal_w);
    ev_break(main_loop, EVBREAK_ALL);
}

int main(int argc, char const *argv[])
{
    struct ev_loop *main_loop = ev_default_loop(0);
    ev_init(&io_w, io_action);
    ev_io_set(&io_w, STDIN_FILENO, EV_READ);
    ev_init(&timer_w, timer_action);
    ev_timer_set(&timer_w, 2,0);
    ev_init(&signal_w, signal_action);
    ev_signal_set(&signal_w, SIGINT);

    ev_io_start(main_loop, &io_w);
    ev_timer_start(main_loop, &timer_w);
    ev_signal_start(main_loop, &signal_w);
    ev_run(main_loop, 0);
    return 0;
}
```

ev_default_loop实现

EV_USE_REALTIME 这个功能我不用。

我只用EV_USE_MONOTONIC

写了几个函数后，感觉思路清晰一些了。

```
#define NUMPRI (EV_MAXPRI - EV_MINPRI + 1)
```

这个优先级我不用。所以NUMPRI为1.

```
实现ev_init
	这个必须实现为宏。
	因为传递进来的类型是多种。只能用宏来模拟c++的模板。
	
```

# jsonrpc

想明白了jsonrpc的通知怎么做了，

进程A作为server，内部同时运行jsonrpc server1和连接自己的client代码，

进程B作为纯的client。

当进程A有状态需要通知时，A内部的client向自己的server发通知，这个信息就会被server转给所有的client.

这样就实现了进程A主动给进程B发送通知的机制。

有了这个，jsonrpc就可以替代dbus的功能来实现进程通信了。

代码规划：

```
jsonrpc_server.c
	里面的对外接口：jrpc_server作为前缀
jsonrpc_client.c
	里面的对外接口，jrpc_client作为前缀。
	
无论server还是client，都以libev作为通信基础。
json库使用cjson。

至于消息的内容，需要后续编写过程中进行优化整理。

```

server端参考jsonrpc-c。

client端我刚无意中发现opensips里有一个实现，代码也很简练。可以参考一下。

我不太在意rpc的传递计算功能。

我只希望传递一个json命令过去。

所以在命令的制定上，我要再看一下snapcast里的做法。

从example切入。

先实现jrpc_server_init函数和jrpc_server结构体。

一个jrpc_server，应该有哪些属性呢？

```
作为server，应该有：
	port。
	一个evloop指针。
	一个ev_io来监听listen_watcher，监听连接。
	一个注册表，注册自己可以处理的所有命令。
		注册的命令用一个jrpc_procedure来表示。
		jrpc_procedure就一个name，一个函数，一个void *data。
		这个回调函数，需要一个jrpc_context。这个context包含了void *data，另外包含了错误信息。
		
```

作为一个server，还有有一个结构体来表示connection。

```
jrpc_connection
	一个connection，是一个io，所以有一个ev_io。
	对应了一个fd。
	有一个buffer来存放收到的消息。buffer配套了2个参数：pos和size。
```

主要的结构体都有了。

现在可以开始看jrpc_server_init做了什么。

server里只有一个ev_loop，用的是默认的。

那么如果要创建多个server实例，会怎么样呢？

应该也没事。

而且还提供了一个jrpc_server_init_with_ev_loop版本让你自己另外传递loop进去。

jrpc_server_init只是一个常用的简单版本而已。

因为每个server都有个ev_loop指针。

发现我用的cjson没有cJSON_Parse_Stream这个函数。

直接把这个函数的实现拷贝过来。不改版本。

jsonrpc_server实现了。整个流程还是非常清晰直观的。都是同步的行为。



今天出现很奇怪的现象，昨天我在另外一台电脑上完全正常的测试程序。

现在换了一台电脑编译运行，就不对了。

问题是ev_default_loop得到的是空指针。

为什么会这样？

if (ev_backend (EV_A)) 这个条件不满足了。

我知道了。因为我gitignore把config.h给忽略了。

而我目前是让libev里直接放了config.h。所以当前就缺失这个文件了。

加上config.h重新编译就好了。

现在测试接收json字符串。结果不对。

怎么收到的数据解析处理不对呢？

```
root->type:3
```

会不会是cjson解析这一步的不对呢？

我直接替换cjson的文件看看。

的确是的。

cjson代码里没有没有版本号呢？

这样很不便于版本管理啊。

现在是提示参数错误。

```
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
{
        "error":        {
                "code": -32600,
                "message":      "request is invalid"
        }
}
```

按道理不应该。

参数是可以不带的吧。

应该是我处理上有不对的地方。

是我判断的条件不对。改了就好了。

现在有个问题，就是只要有一次发送错了json。那么后面解析都不对了。

测试一下jsonrpc-c的。发现这个在解析出错后，client就退出了。

我是没有退出的。

我把jsonrpc-c也改成不退出的看看。

碰到一次错误解析后，之后还是正常的。

那就是我的代码还有问题。

从connection_cb开始看。

目前测试简单的几个字符发送。不会触发解析。我觉得这个符合预期。

但是随便发了几个字符，再发一个正常的json。

后面就一直错误无法恢复了。

当前对buffer这一块的处理，不是很直观。

需要把jsonrpc-c的调试一下。

也是一样的问题。

这个时候的buffer内容是这样。

```
fdfdf
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
{"id":1,"jsonrpc":"2.0","method":"sayHello"}
```

需要在出错的时候，把buffer整个复位一下。

现在把server的destroy的逻辑写一下。

