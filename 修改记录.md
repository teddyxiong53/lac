# cjson

这个不用写，但是以编译这个为入口，把autotools的编译链接过程走通。

现在可以编译通过。但是生成的只有la结尾的文件。没有看到a或者so文件。

# tinyparam

C语言切分字符串

https://blog.csdn.net/SweeNeil/article/details/84787945

```
char *strtok_r(char *str, const char *delim, char **saveptr);
```

这个才是线程安全的。

测试代码：

```
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "system.audio.volume";
    char* ptr;
    char* p;
    printf("before strtok:  str=%s\n", str);
    printf("begin:\n");
    ptr = strtok_r(str, ".", &p);
    while (ptr != NULL) {
        printf("str=%s\n", str);
        printf("ptr=%s\n", ptr);
        ptr = strtok_r(NULL, ".", &p);
    }
    return 0;
}
```

这样打印出来是：

```
before strtok:  str=system.audio.volume
begin:
str=system
ptr=system
str=system
ptr=audio
str=system
ptr=volume
```

那我以ptr的作为取值对象。

代码这样：

```
#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = "system.audio.volume";
    char* ptr;
    char* p;
    printf("before strtok:  str=%s\n", str);
    ptr = strtok_r(str, ".", &p);
    while (ptr != NULL) {
        printf("ptr=%s\n", ptr);
        ptr = strtok_r(NULL, ".", &p);
    }
    return 0;
}
```

写入的时候，进行truncate操作。前面会有一堆的NUL。

需要rewind一下。

现在tinyparam功能完成了。

# tinyev

接下来是实现tinyev。

这个就比较麻烦一点。需要先研究一下libev的内容。

我就用3个文件：ev.c、ev.h、ev_epoll.c。

看了一下代码风格，真的是非常别扭。但是回头看了一下libtuv。这个文件就是比较多。

相比之下，还是libev代码量算是少的。

我先保证可以把这个例子编译运行起来。

```
#include <ev.h>
#include <stdio.h>
#include <signal.h>
#include <sys/unistd.h>

ev_io io_w;
ev_timer timer_w;
ev_signal signal_w;

void io_action(struct ev_loop *main_loop, ev_io *io_w, int e)
{
    int ret;
    char buf[1024] = {0};
    puts("in io cb\n");
    read(STDIN_FILENO, buf, sizeof(buf));
    buf[1023] = '\0';
    printf("read a string:%s\n", buf);
    ev_io_stop(main_loop, io_w);
}
void timer_action(struct ev_loop *main_loop, ev_timer *timer_w, int e)
{
    puts("in timer cb\n");
    ev_timer_stop(main_loop, timer_w);
}
void signal_action(struct ev_loop *main_loop, ev_signal *signal_w, int e)
{
    puts("in signal cb\n");
    ev_signal_stop(main_loop, signal_w);
    ev_break(main_loop, EVBREAK_ALL);
}

int main(int argc, char const *argv[])
{
    struct ev_loop *main_loop = ev_default_loop(0);
    ev_init(&io_w, io_action);
    ev_io_set(&io_w, STDIN_FILENO, EV_READ);
    ev_init(&timer_w, timer_action);
    ev_timer_set(&timer_w, 2,0);
    ev_init(&signal_w, signal_action);
    ev_signal_set(&signal_w, SIGINT);

    ev_io_start(main_loop, &io_w);
    ev_timer_start(main_loop, &timer_w);
    ev_signal_start(main_loop, &signal_w);
    ev_run(main_loop, 0);
    return 0;
}
```

ev_default_loop实现

EV_USE_REALTIME 这个功能我不用。

我只用EV_USE_MONOTONIC

写了几个函数后，感觉思路清晰一些了。

```
#define NUMPRI (EV_MAXPRI - EV_MINPRI + 1)
```

这个优先级我不用。所以NUMPRI为1.

```
实现ev_init
	这个必须实现为宏。
	因为传递进来的类型是多种。只能用宏来模拟c++的模板。
	
```

